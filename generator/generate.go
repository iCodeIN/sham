package generator

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"

	"github.com/dave/jennifer/jen"
)

// Generate produces fakes of interfaces parsed from r.
func Generate(r io.Reader, w io.Writer) error {
	var fs token.FileSet

	root, err := parser.ParseFile(
		&fs,
		"stdin",
		r,
		parser.ParseComments|parser.AllErrors,
	)
	if err != nil {
		return err
	}

	var v visitor

	ast.Walk(&v, root)

	if v.Err != nil {
		return v.Err
	}

	fmt.Fprintf(w, "%#v", v.File)

	return nil
}

type visitor struct {
	Err     error
	Package string
	File    *jen.File
}

func (v *visitor) Visit(n ast.Node) ast.Visitor {
	if n == nil || v.Err != nil {
		return nil
	}

	var descend = true

	switch n := n.(type) {
	case *ast.File:
		descend, v.Err = v.visitFile(n)
	case *ast.TypeSpec:
		descend, v.Err = v.visitTypeSpec(n)
	}

	if descend && v.Err == nil {
		return v
	}

	return nil
}

func (v *visitor) visitFile(n *ast.File) (bool, error) {
	v.Package = n.Name.Name

	v.File = jen.NewFile("fixtures")
	v.File.HeaderComment("Code generated by sham. DO NOT EDIT.")

	return true, nil
}

func (v *visitor) visitTypeSpec(spec *ast.TypeSpec) (bool, error) {
	if !spec.Name.IsExported() {
		return false, nil
	}

	iface, ok := spec.Type.(*ast.InterfaceType)
	if !ok {
		return false, nil
	}

	v.File.Commentf(
		"%s is a test implementation of the %s.%s interface.",
		spec.Name.Name,
		v.Package,
		spec.Name.Name,
	)

	v.File.
		Type().
		Id(spec.Name.Name).
		StructFunc(func(grp *jen.Group) {
			for _, m := range iface.Methods.List {
				name := m.Names[0]
				if !name.IsExported() {
					continue
				}

				grp.Id(stubName(m)).
					Func().
					ParamsFunc(func(grp *jen.Group) {
					})
			}
		})

	for _, m := range iface.Methods.List {
		name := m.Names[0]
		if !name.IsExported() {
			continue
		}

		v.File.
			Func().
			Params(
				jen.Id("x").
					Id("*" + spec.Name.Name),
			).
			Id(name.Name).
			ParamsFunc(func(grp *jen.Group) {
			}).
			BlockFunc(func(grp *jen.Group) {
				grp.
					If(
						jen.Id("x").Dot(stubName(m)).Op("!=").Nil(),
					).
					Block(
						jen.Id("x").Dot(stubName(m)).Call(),
					)
			})
	}

	return false, nil
}

func stubName(n *ast.Field) string {
	return n.Names[0].Name + "Func"
}
