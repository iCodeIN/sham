package generator

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"io/ioutil"
	"path/filepath"

	"github.com/dave/jennifer/jen"
)

// Generate produces fakes of interfaces parsed from r.
func Generate(src, pkg string, w io.Writer) error {
	src, err := filepath.Abs(src)
	if err != nil {
		return err
	}

	inPath, err := packagePath(src)
	if err != nil {
		return err
	}

	var fs token.FileSet

	data, err := ioutil.ReadFile(src)
	if err != nil {
		return err
	}

	root, err := parser.ParseFile(
		&fs,
		src,
		data,
		parser.AllErrors,
	)
	if err != nil {
		return err
	}

	v := &visitor{
		InputPackagePath:  inPath,
		OutputPackageName: pkg,
	}

	ast.Walk(v, root)

	_, err = fmt.Fprintf(w, "%#v", v.Code)
	return err
}

type visitor struct {
	InputPackagePath  string
	OutputPackageName string
	Code              *jen.File

	// Populated from ast.File.
	interfacePackage string

	// Stateful, based on current interface.
	interfaceName string
	structName    string

	// Stateful, based on current method.
	vars          *variables
	methodType    *ast.FuncType
	methodInputs  []*ast.Field
	methodOutputs []*ast.Field
	methodName    string
	fieldName     string
}

func (v *visitor) Visit(n ast.Node) ast.Visitor {
	switch n := n.(type) {
	case *ast.File:
		return v.visitFile(n)
	case *ast.TypeSpec:
		return v.visitTypeSpec(n)
	case nil:
		return nil
	default:
		return v
	}
}

func (v *visitor) visitFile(n *ast.File) ast.Visitor {
	v.interfacePackage = n.Name.Name
	v.Code = jen.NewFile(v.OutputPackageName)
	v.Code.HeaderComment("Code generated by sham. DO NOT EDIT.")
	v.Code.HeaderComment("https://github.com/jmalloc/sham")
	return v
}

func (v *visitor) visitTypeSpec(n *ast.TypeSpec) ast.Visitor {
	if !n.Name.IsExported() {
		return nil
	}

	iface, ok := n.Type.(*ast.InterfaceType)
	if !ok {
		return nil
	}

	v.interfaceName = n.Name.Name
	v.structName = n.Name.Name

	v.Code.Commentf(
		"%s is a test implementation of the %s.%s interface.",
		v.structName,
		v.interfacePackage,
		v.interfaceName,
	)

	v.Code.
		Type().
		Id(v.structName).
		StructFunc(
			func(out *jen.Group) {
				out.Commentf(
					"%s is the default implementation of the interface.",
					v.interfaceName,
				)
				out.Comment(
					"If it is nil, each method will return an error (or panic).",
				)
				out.Qual(v.InputPackagePath, v.interfaceName)

				for _, m := range iface.Methods.List {
					out.Line()
					v.visitMethod(out, m, v.generateStubField)
				}
			},
		)

	for _, m := range iface.Methods.List {
		v.visitMethod(v.Code.Group, m, v.generateStubMethod)
		v.Code.Line()
	}

	return nil
}

func (v *visitor) visitMethod(
	out *jen.Group,
	m *ast.Field,
	gen func(*jen.Group),
) {
	v.methodType = m.Type.(*ast.FuncType)
	v.vars = newVariables(v.methodType)
	v.methodName = m.Names[0].Name
	v.fieldName = v.methodName + "Func"

	if v.methodType.Params != nil {
		v.methodInputs = v.methodType.Params.List
	} else {
		v.methodInputs = nil
	}

	if v.methodType.Results != nil {
		v.methodOutputs = v.methodType.Results.List
	} else {
		v.methodOutputs = nil
	}

	gen(out)
}

// newType generates the code for a field type.
func (v *visitor) newType(x ast.Expr) jen.Code {
	switch x := x.(type) {
	case *ast.Ident:
		return jen.Id(x.Name)
	case *ast.Ellipsis:
		return jen.Op("...").Add(
			v.newType(x.Elt),
		)
		// case *ast.SelectorExpr:
		// return jen.Qual(

		// )
		// X   Expr   // expression
		// Sel *Ident // field selector
	}

	panic(fmt.Sprintf("unsupported expression type: %T", x))
}
